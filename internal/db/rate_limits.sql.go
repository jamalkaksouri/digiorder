// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: rate_limits.sql

package db

import (
	"context"
	"time"
)

const countLoginAttempts = `-- name: CountLoginAttempts :one
SELECT COALESCE(SUM(requests_count), 0)::bigint as count
FROM api_rate_limits
WHERE client_id = $1 
  AND endpoint = '/api/v1/auth/login'
  AND window_start >= $2
`

type CountLoginAttemptsParams struct {
	ClientID    string
	WindowStart time.Time
}

func (q *Queries) CountLoginAttempts(ctx context.Context, arg CountLoginAttemptsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLoginAttempts, arg.ClientID, arg.WindowStart)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOldRateLimits = `-- name: DeleteOldRateLimits :exec
DELETE FROM api_rate_limits
WHERE window_start < $1
`

func (q *Queries) DeleteOldRateLimits(ctx context.Context, windowStart time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteOldRateLimits, windowStart)
	return err
}

const getOrCreateRateLimit = `-- name: GetOrCreateRateLimit :one

INSERT INTO api_rate_limits (client_id, endpoint, requests_count, window_start)
VALUES ($1, $2, 1, $3)
ON CONFLICT (client_id, endpoint, window_start) 
DO UPDATE SET 
    requests_count = api_rate_limits.requests_count + 1,
    created_at = NOW()
RETURNING id, client_id, endpoint, requests_count, window_start, created_at, exclude_from_tracking
`

type GetOrCreateRateLimitParams struct {
	ClientID    string
	Endpoint    string
	WindowStart time.Time
}

// internal/db/query/rate_limits.sql
func (q *Queries) GetOrCreateRateLimit(ctx context.Context, arg GetOrCreateRateLimitParams) (ApiRateLimit, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateRateLimit, arg.ClientID, arg.Endpoint, arg.WindowStart)
	var i ApiRateLimit
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Endpoint,
		&i.RequestsCount,
		&i.WindowStart,
		&i.CreatedAt,
		&i.ExcludeFromTracking,
	)
	return i, err
}

const getRateLimitByWindow = `-- name: GetRateLimitByWindow :one
SELECT id, client_id, endpoint, requests_count, window_start, created_at, exclude_from_tracking FROM api_rate_limits
WHERE client_id = $1 
  AND endpoint = $2 
  AND window_start = $3
LIMIT 1
`

type GetRateLimitByWindowParams struct {
	ClientID    string
	Endpoint    string
	WindowStart time.Time
}

func (q *Queries) GetRateLimitByWindow(ctx context.Context, arg GetRateLimitByWindowParams) (ApiRateLimit, error) {
	row := q.db.QueryRowContext(ctx, getRateLimitByWindow, arg.ClientID, arg.Endpoint, arg.WindowStart)
	var i ApiRateLimit
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Endpoint,
		&i.RequestsCount,
		&i.WindowStart,
		&i.CreatedAt,
		&i.ExcludeFromTracking,
	)
	return i, err
}

const getRateLimitStats = `-- name: GetRateLimitStats :many
SELECT 
    client_id,
    endpoint,
    SUM(requests_count) as total_requests,
    MAX(window_start) as last_request
FROM api_rate_limits
WHERE window_start >= NOW() - INTERVAL '1 hour'
GROUP BY client_id, endpoint
ORDER BY total_requests DESC
LIMIT $1
`

type GetRateLimitStatsRow struct {
	ClientID      string
	Endpoint      string
	TotalRequests int64
	LastRequest   interface{}
}

func (q *Queries) GetRateLimitStats(ctx context.Context, limit int32) ([]GetRateLimitStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRateLimitStats, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRateLimitStatsRow
	for rows.Next() {
		var i GetRateLimitStatsRow
		if err := rows.Scan(
			&i.ClientID,
			&i.Endpoint,
			&i.TotalRequests,
			&i.LastRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRateLimitedIPs = `-- name: GetTopRateLimitedIPs :many
SELECT 
    client_id,
    COUNT(*) as violation_count,
    MAX(window_start) as last_violation
FROM api_rate_limits
WHERE requests_count > $1
  AND window_start >= NOW() - INTERVAL '24 hours'
GROUP BY client_id
ORDER BY violation_count DESC
LIMIT $2
`

type GetTopRateLimitedIPsParams struct {
	RequestsCount int32
	Limit         int32
}

type GetTopRateLimitedIPsRow struct {
	ClientID       string
	ViolationCount int64
	LastViolation  interface{}
}

func (q *Queries) GetTopRateLimitedIPs(ctx context.Context, arg GetTopRateLimitedIPsParams) ([]GetTopRateLimitedIPsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopRateLimitedIPs, arg.RequestsCount, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopRateLimitedIPsRow
	for rows.Next() {
		var i GetTopRateLimitedIPsRow
		if err := rows.Scan(&i.ClientID, &i.ViolationCount, &i.LastViolation); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordLoginAttempt = `-- name: RecordLoginAttempt :one
INSERT INTO api_rate_limits (client_id, endpoint, requests_count, window_start)
VALUES ($1, '/api/v1/auth/login', 1, NOW())
ON CONFLICT (client_id, endpoint, window_start) 
DO UPDATE SET requests_count = api_rate_limits.requests_count + 1
RETURNING id, client_id, endpoint, requests_count, window_start, created_at, exclude_from_tracking
`

func (q *Queries) RecordLoginAttempt(ctx context.Context, clientID string) (ApiRateLimit, error) {
	row := q.db.QueryRowContext(ctx, recordLoginAttempt, clientID)
	var i ApiRateLimit
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Endpoint,
		&i.RequestsCount,
		&i.WindowStart,
		&i.CreatedAt,
		&i.ExcludeFromTracking,
	)
	return i, err
}
