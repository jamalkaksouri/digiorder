// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: permissions.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const assignPermissionToRole = `-- name: AssignPermissionToRole :one
INSERT INTO role_permissions (role_id, permission_id)
VALUES ($1, $2)
RETURNING id, role_id, permission_id, created_at
`

type AssignPermissionToRoleParams struct {
	RoleID       int32
	PermissionID int32
}

func (q *Queries) AssignPermissionToRole(ctx context.Context, arg AssignPermissionToRoleParams) (RolePermission, error) {
	row := q.db.QueryRowContext(ctx, assignPermissionToRole, arg.RoleID, arg.PermissionID)
	var i RolePermission
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.PermissionID,
		&i.CreatedAt,
	)
	return i, err
}

const checkRolePermission = `-- name: CheckRolePermission :one
SELECT EXISTS(
    SELECT 1 FROM role_permissions rp
    JOIN permissions p ON rp.permission_id = p.id
    WHERE rp.role_id = $1
    AND p.resource = $2
    AND p.action = $3
) as has_permission
`

type CheckRolePermissionParams struct {
	RoleID   int32
	Resource string
	Action   string
}

func (q *Queries) CheckRolePermission(ctx context.Context, arg CheckRolePermissionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkRolePermission, arg.RoleID, arg.Resource, arg.Action)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const countAdminUsers = `-- name: CountAdminUsers :one
SELECT COUNT(*) FROM users
WHERE role_id = 1 AND deleted_at IS NULL
`

func (q *Queries) CountAdminUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAdminUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_logs (user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
RETURNING id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, created_at
`

type CreateAuditLogParams struct {
	UserID     uuid.NullUUID
	Action     string
	EntityType string
	EntityID   string
	OldValues  pqtype.NullRawMessage
	NewValues  pqtype.NullRawMessage
	IpAddress  sql.NullString
	UserAgent  sql.NullString
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRowContext(ctx, createAuditLog,
		arg.UserID,
		arg.Action,
		arg.EntityType,
		arg.EntityID,
		arg.OldValues,
		arg.NewValues,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.OldValues,
		&i.NewValues,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions (name, resource, action, description)
VALUES ($1, $2, $3, $4)
RETURNING id, name, resource, action, description, created_at
`

type CreatePermissionParams struct {
	Name        string
	Resource    string
	Action      string
	Description sql.NullString
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permission, error) {
	row := q.db.QueryRowContext(ctx, createPermission,
		arg.Name,
		arg.Resource,
		arg.Action,
		arg.Description,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Resource,
		&i.Action,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions WHERE id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePermission, id)
	return err
}

const getAuditLog = `-- name: GetAuditLog :one
SELECT id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, created_at FROM audit_logs WHERE id = $1
`

func (q *Queries) GetAuditLog(ctx context.Context, id uuid.UUID) (AuditLog, error) {
	row := q.db.QueryRowContext(ctx, getAuditLog, id)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.EntityType,
		&i.EntityID,
		&i.OldValues,
		&i.NewValues,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
	)
	return i, err
}

const getAuditLogStats = `-- name: GetAuditLogStats :one
SELECT
    COUNT(*) as total_logs,
    COUNT(DISTINCT user_id) as unique_users,
    COUNT(DISTINCT entity_type) as unique_entities
FROM audit_logs
WHERE created_at >= NOW() - INTERVAL '24 hours'
`

type GetAuditLogStatsRow struct {
	TotalLogs      int64
	UniqueUsers    int64
	UniqueEntities int64
}

func (q *Queries) GetAuditLogStats(ctx context.Context) (GetAuditLogStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getAuditLogStats)
	var i GetAuditLogStatsRow
	err := row.Scan(&i.TotalLogs, &i.UniqueUsers, &i.UniqueEntities)
	return i, err
}

const getAuditLogsByAction = `-- name: GetAuditLogsByAction :many
SELECT id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, created_at FROM audit_logs
WHERE action = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetAuditLogsByActionParams struct {
	Action string
	Offset int32
	Limit  int32
}

func (q *Queries) GetAuditLogsByAction(ctx context.Context, arg GetAuditLogsByActionParams) ([]AuditLog, error) {
	rows, err := q.db.QueryContext(ctx, getAuditLogsByAction, arg.Action, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByEntity = `-- name: GetAuditLogsByEntity :many
SELECT id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, created_at FROM audit_logs
WHERE entity_type = $1
  AND entity_id = $2
ORDER BY created_at DESC
LIMIT $4 OFFSET $3
`

type GetAuditLogsByEntityParams struct {
	EntityType string
	EntityID   string
	Offset     int32
	Limit      int32
}

func (q *Queries) GetAuditLogsByEntity(ctx context.Context, arg GetAuditLogsByEntityParams) ([]AuditLog, error) {
	rows, err := q.db.QueryContext(ctx, getAuditLogsByEntity,
		arg.EntityType,
		arg.EntityID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByUser = `-- name: GetAuditLogsByUser :many
SELECT id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, created_at FROM audit_logs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $3 OFFSET $2
`

type GetAuditLogsByUserParams struct {
	UserID uuid.NullUUID
	Offset int32
	Limit  int32
}

func (q *Queries) GetAuditLogsByUser(ctx context.Context, arg GetAuditLogsByUserParams) ([]AuditLog, error) {
	rows, err := q.db.QueryContext(ctx, getAuditLogsByUser, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermission = `-- name: GetPermission :one
SELECT id, name, resource, action, description, created_at FROM permissions WHERE id = $1
`

func (q *Queries) GetPermission(ctx context.Context, id int32) (Permission, error) {
	row := q.db.QueryRowContext(ctx, getPermission, id)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Resource,
		&i.Action,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT p.id, p.name, p.resource, p.action, p.description, p.created_at FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE rp.role_id = $1
ORDER BY p.resource, p.action
`

func (q *Queries) GetRolePermissions(ctx context.Context, roleID int32) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Resource,
			&i.Action,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveUsers = `-- name: ListActiveUsers :many
SELECT id, username, full_name, password_hash, role_id, created_at, deleted_at FROM users
WHERE deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListActiveUsersParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) ListActiveUsers(ctx context.Context, arg ListActiveUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listActiveUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FullName,
			&i.PasswordHash,
			&i.RoleID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT id, user_id, action, entity_type, entity_id, old_values, new_values, ip_address, user_agent, created_at FROM audit_logs
ORDER BY created_at DESC
LIMIT $2 OFFSET $1
`

type ListAuditLogsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.QueryContext(ctx, listAuditLogs, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuditLog
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Action,
			&i.EntityType,
			&i.EntityID,
			&i.OldValues,
			&i.NewValues,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermissions = `-- name: ListPermissions :many
SELECT id, name, resource, action, description, created_at FROM permissions
ORDER BY resource, action
LIMIT $2 OFFSET $1
`

type ListPermissionsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) ListPermissions(ctx context.Context, arg ListPermissionsParams) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, listPermissions, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Resource,
			&i.Action,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermissionsByResource = `-- name: ListPermissionsByResource :many
SELECT id, name, resource, action, description, created_at FROM permissions
WHERE resource = $1
ORDER BY action
LIMIT $3 OFFSET $2
`

type ListPermissionsByResourceParams struct {
	Resource string
	Offset   int32
	Limit    int32
}

func (q *Queries) ListPermissionsByResource(ctx context.Context, arg ListPermissionsByResourceParams) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, listPermissionsByResource, arg.Resource, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Resource,
			&i.Action,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokePermissionFromRole = `-- name: RevokePermissionFromRole :exec
DELETE FROM role_permissions
WHERE role_id = $1 AND permission_id = $2
`

type RevokePermissionFromRoleParams struct {
	RoleID       int32
	PermissionID int32
}

func (q *Queries) RevokePermissionFromRole(ctx context.Context, arg RevokePermissionFromRoleParams) error {
	_, err := q.db.ExecContext(ctx, revokePermissionFromRole, arg.RoleID, arg.PermissionID)
	return err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, softDeleteUser, id)
	return err
}

const updatePermission = `-- name: UpdatePermission :one
UPDATE permissions
SET
    name = COALESCE(NULLIF($1, ''), name),
    resource = COALESCE(NULLIF($2, ''), resource),
    action = COALESCE(NULLIF($3, ''), action),
    description = COALESCE(NULLIF($4, ''), description)
WHERE id = $5
RETURNING id, name, resource, action, description, created_at
`

type UpdatePermissionParams struct {
	Name        any
	Resource    any
	Action      any
	Description any
	ID          int32
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) (Permission, error) {
	row := q.db.QueryRowContext(ctx, updatePermission,
		arg.Name,
		arg.Resource,
		arg.Action,
		arg.Description,
		arg.ID,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Resource,
		&i.Action,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}
