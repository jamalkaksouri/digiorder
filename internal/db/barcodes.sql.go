// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: barcodes.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createProductBarcode = `-- name: CreateProductBarcode :one
INSERT INTO product_barcodes (
    product_id, barcode, barcode_type
) VALUES (
    $1, $2, $3
)
RETURNING id, product_id, barcode, barcode_type
`

type CreateProductBarcodeParams struct {
	ProductID   uuid.NullUUID
	Barcode     string
	BarcodeType sql.NullString
}

func (q *Queries) CreateProductBarcode(ctx context.Context, arg CreateProductBarcodeParams) (ProductBarcode, error) {
	row := q.db.QueryRowContext(ctx, createProductBarcode, arg.ProductID, arg.Barcode, arg.BarcodeType)
	var i ProductBarcode
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Barcode,
		&i.BarcodeType,
	)
	return i, err
}

const deleteProductBarcode = `-- name: DeleteProductBarcode :exec
DELETE FROM product_barcodes WHERE id = $1
`

func (q *Queries) DeleteProductBarcode(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProductBarcode, id)
	return err
}

const getProductBarcodes = `-- name: GetProductBarcodes :many
SELECT id, product_id, barcode, barcode_type FROM product_barcodes
WHERE product_id = $1
`

func (q *Queries) GetProductBarcodes(ctx context.Context, productID uuid.NullUUID) ([]ProductBarcode, error) {
	rows, err := q.db.QueryContext(ctx, getProductBarcodes, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductBarcode
	for rows.Next() {
		var i ProductBarcode
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Barcode,
			&i.BarcodeType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByBarcode = `-- name: GetProductByBarcode :one
SELECT p.id, p.name, p.brand, p.dosage_form_id, p.strength, p.unit, p.category_id, p.description, p.created_at FROM products p
JOIN product_barcodes pb ON p.id = pb.product_id
WHERE pb.barcode = $1 LIMIT 1
`

func (q *Queries) GetProductByBarcode(ctx context.Context, barcode string) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByBarcode, barcode)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Brand,
		&i.DosageFormID,
		&i.Strength,
		&i.Unit,
		&i.CategoryID,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const searchProductsByBarcode = `-- name: SearchProductsByBarcode :many
SELECT p.id, p.name, p.brand, p.dosage_form_id, p.strength, p.unit, p.category_id, p.description, p.created_at FROM products p
JOIN product_barcodes pb ON p.id = pb.product_id
WHERE pb.barcode ILIKE '%' || $1 || '%'
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type SearchProductsByBarcodeParams struct {
	Column1 sql.NullString
	Limit   int32
	Offset  int32
}

func (q *Queries) SearchProductsByBarcode(ctx context.Context, arg SearchProductsByBarcodeParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, searchProductsByBarcode, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Brand,
			&i.DosageFormID,
			&i.Strength,
			&i.Unit,
			&i.CategoryID,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
