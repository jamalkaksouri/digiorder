// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: login_attempts.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const archiveOldRateLimits = `-- name: ArchiveOldRateLimits :exec
SELECT archive_old_rate_limits()
`

func (q *Queries) ArchiveOldRateLimits(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, archiveOldRateLimits)
	return err
}

const cleanupOldLoginAttempts = `-- name: CleanupOldLoginAttempts :exec
SELECT cleanup_old_login_attempts()
`

func (q *Queries) CleanupOldLoginAttempts(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupOldLoginAttempts)
	return err
}

const countFailedAttempts = `-- name: CountFailedAttempts :one
SELECT COUNT(*) FROM login_attempts_log
WHERE ip_address = $1
  AND attempt_time >= $2
  AND success = false
`

type CountFailedAttemptsParams struct {
	IpAddress string
	Since     sql.NullTime
}

func (q *Queries) CountFailedAttempts(ctx context.Context, arg CountFailedAttemptsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countFailedAttempts, arg.IpAddress, arg.Since)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOldRateLimitsExcludingHealthMetrics = `-- name: DeleteOldRateLimitsExcludingHealthMetrics :exec
DELETE FROM api_rate_limits
WHERE window_start < $1
  AND endpoint NOT IN ('/health', '/metrics', '/api/health', '/api/metrics')
`

func (q *Queries) DeleteOldRateLimitsExcludingHealthMetrics(ctx context.Context, cutoff time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteOldRateLimitsExcludingHealthMetrics, cutoff)
	return err
}

const getCurrentlyBlockedIPs = `-- name: GetCurrentlyBlockedIPs :many
SELECT client_id, endpoint, total_attempts, last_attempt, block_windows FROM currently_blocked_ips
`

func (q *Queries) GetCurrentlyBlockedIPs(ctx context.Context) ([]CurrentlyBlockedIp, error) {
	rows, err := q.db.QueryContext(ctx, getCurrentlyBlockedIPs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CurrentlyBlockedIp
	for rows.Next() {
		var i CurrentlyBlockedIp
		if err := rows.Scan(
			&i.ClientID,
			&i.Endpoint,
			&i.TotalAttempts,
			&i.LastAttempt,
			&i.BlockWindows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginAttemptStats = `-- name: GetLoginAttemptStats :many
SELECT hour, total_attempts, successful, failed, rate_limited_attempts, unique_ips, unique_usernames FROM login_attempt_stats
`

func (q *Queries) GetLoginAttemptStats(ctx context.Context) ([]LoginAttemptStat, error) {
	rows, err := q.db.QueryContext(ctx, getLoginAttemptStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoginAttemptStat
	for rows.Next() {
		var i LoginAttemptStat
		if err := rows.Scan(
			&i.Hour,
			&i.TotalAttempts,
			&i.Successful,
			&i.Failed,
			&i.RateLimitedAttempts,
			&i.UniqueIps,
			&i.UniqueUsernames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginAttemptsByUsername = `-- name: GetLoginAttemptsByUsername :many
SELECT id, username, ip_address, user_agent, attempt_time, success, failure_reason, rate_limited, rate_limit_released_at, released_by, session_id, country, city, device_info, created_at FROM login_attempts_log
WHERE username = $1
  AND attempt_time >= $2
ORDER BY attempt_time DESC
LIMIT $3
`

type GetLoginAttemptsByUsernameParams struct {
	Username string
	Since    sql.NullTime
	Limit    int32
}

func (q *Queries) GetLoginAttemptsByUsername(ctx context.Context, arg GetLoginAttemptsByUsernameParams) ([]LoginAttemptsLog, error) {
	rows, err := q.db.QueryContext(ctx, getLoginAttemptsByUsername, arg.Username, arg.Since, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoginAttemptsLog
	for rows.Next() {
		var i LoginAttemptsLog
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.IpAddress,
			&i.UserAgent,
			&i.AttemptTime,
			&i.Success,
			&i.FailureReason,
			&i.RateLimited,
			&i.RateLimitReleasedAt,
			&i.ReleasedBy,
			&i.SessionID,
			&i.Country,
			&i.City,
			&i.DeviceInfo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginSecurityReport = `-- name: GetLoginSecurityReport :many
SELECT 
    ip_address,
    COUNT(*) as total_attempts,
    COUNT(*) FILTER (WHERE success = false) as failed_attempts,
    COUNT(*) FILTER (WHERE rate_limited = true) as rate_limited_count,
    COUNT(DISTINCT username) as unique_usernames_tried,
    MIN(attempt_time) as first_attempt,
    MAX(attempt_time) as last_attempt,
    ARRAY_AGG(DISTINCT username) as attempted_usernames
FROM login_attempts_log
WHERE attempt_time >= NOW() - INTERVAL '24 hours'
GROUP BY ip_address
HAVING COUNT(*) FILTER (WHERE success = false) >= 3
ORDER BY failed_attempts DESC
LIMIT $1
`

type GetLoginSecurityReportRow struct {
	IpAddress            string
	TotalAttempts        int64
	FailedAttempts       int64
	RateLimitedCount     int64
	UniqueUsernamesTried int64
	FirstAttempt         interface{}
	LastAttempt          interface{}
	AttemptedUsernames   interface{}
}

func (q *Queries) GetLoginSecurityReport(ctx context.Context, limit int32) ([]GetLoginSecurityReportRow, error) {
	rows, err := q.db.QueryContext(ctx, getLoginSecurityReport, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLoginSecurityReportRow
	for rows.Next() {
		var i GetLoginSecurityReportRow
		if err := rows.Scan(
			&i.IpAddress,
			&i.TotalAttempts,
			&i.FailedAttempts,
			&i.RateLimitedCount,
			&i.UniqueUsernamesTried,
			&i.FirstAttempt,
			&i.LastAttempt,
			&i.AttemptedUsernames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRateLimitReleases = `-- name: GetRateLimitReleases :many
SELECT id, client_id, ip_address, username, blocked_at, released_at, released_by, released_by_user_id, block_duration, attempts_count, release_reason, created_at FROM rate_limit_releases
WHERE ip_address = $1
ORDER BY released_at DESC
LIMIT $2
`

type GetRateLimitReleasesParams struct {
	IpAddress string
	Limit     int32
}

func (q *Queries) GetRateLimitReleases(ctx context.Context, arg GetRateLimitReleasesParams) ([]RateLimitRelease, error) {
	rows, err := q.db.QueryContext(ctx, getRateLimitReleases, arg.IpAddress, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RateLimitRelease
	for rows.Next() {
		var i RateLimitRelease
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.IpAddress,
			&i.Username,
			&i.BlockedAt,
			&i.ReleasedAt,
			&i.ReleasedBy,
			&i.ReleasedByUserID,
			&i.BlockDuration,
			&i.AttemptsCount,
			&i.ReleaseReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRateLimitWithExclusion = `-- name: GetRateLimitWithExclusion :many
SELECT id, client_id, endpoint, requests_count, window_start, created_at, exclude_from_tracking FROM api_rate_limits
WHERE client_id = $1
  AND endpoint = $2
  AND window_start >= $3
  AND (exclude_from_tracking = false OR exclude_from_tracking IS NULL)
`

type GetRateLimitWithExclusionParams struct {
	ClientID    string
	Endpoint    string
	WindowStart time.Time
}

func (q *Queries) GetRateLimitWithExclusion(ctx context.Context, arg GetRateLimitWithExclusionParams) ([]ApiRateLimit, error) {
	rows, err := q.db.QueryContext(ctx, getRateLimitWithExclusion, arg.ClientID, arg.Endpoint, arg.WindowStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiRateLimit
	for rows.Next() {
		var i ApiRateLimit
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Endpoint,
			&i.RequestsCount,
			&i.WindowStart,
			&i.CreatedAt,
			&i.ExcludeFromTracking,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRateLimitedAttempts = `-- name: GetRateLimitedAttempts :many
SELECT id, username, ip_address, user_agent, attempt_time, success, failure_reason, rate_limited, rate_limit_released_at, released_by, session_id, country, city, device_info, created_at FROM login_attempts_log
WHERE rate_limited = true
  AND attempt_time >= NOW() - INTERVAL '24 hours'
ORDER BY attempt_time DESC
LIMIT $2 OFFSET $1
`

type GetRateLimitedAttemptsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetRateLimitedAttempts(ctx context.Context, arg GetRateLimitedAttemptsParams) ([]LoginAttemptsLog, error) {
	rows, err := q.db.QueryContext(ctx, getRateLimitedAttempts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoginAttemptsLog
	for rows.Next() {
		var i LoginAttemptsLog
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.IpAddress,
			&i.UserAgent,
			&i.AttemptTime,
			&i.Success,
			&i.FailureReason,
			&i.RateLimited,
			&i.RateLimitReleasedAt,
			&i.ReleasedBy,
			&i.SessionID,
			&i.Country,
			&i.City,
			&i.DeviceInfo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentLoginAttempts = `-- name: GetRecentLoginAttempts :many
SELECT id, username, ip_address, user_agent, attempt_time, success, failure_reason, rate_limited, rate_limit_released_at, released_by, session_id, country, city, device_info, created_at FROM login_attempts_log
WHERE ip_address = $1
  AND attempt_time >= $2
ORDER BY attempt_time DESC
LIMIT $3
`

type GetRecentLoginAttemptsParams struct {
	IpAddress string
	Since     sql.NullTime
	Limit     int32
}

func (q *Queries) GetRecentLoginAttempts(ctx context.Context, arg GetRecentLoginAttemptsParams) ([]LoginAttemptsLog, error) {
	rows, err := q.db.QueryContext(ctx, getRecentLoginAttempts, arg.IpAddress, arg.Since, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoginAttemptsLog
	for rows.Next() {
		var i LoginAttemptsLog
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.IpAddress,
			&i.UserAgent,
			&i.AttemptTime,
			&i.Success,
			&i.FailureReason,
			&i.RateLimited,
			&i.RateLimitReleasedAt,
			&i.ReleasedBy,
			&i.SessionID,
			&i.Country,
			&i.City,
			&i.DeviceInfo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLoginHistory = `-- name: GetUserLoginHistory :many
SELECT 
    attempt_time,
    ip_address,
    user_agent,
    success,
    failure_reason,
    rate_limited
FROM login_attempts_log
WHERE username = $1
ORDER BY attempt_time DESC
LIMIT $3 OFFSET $2
`

type GetUserLoginHistoryParams struct {
	Username string
	Offset   int32
	Limit    int32
}

type GetUserLoginHistoryRow struct {
	AttemptTime   sql.NullTime
	IpAddress     string
	UserAgent     sql.NullString
	Success       bool
	FailureReason sql.NullString
	RateLimited   sql.NullBool
}

func (q *Queries) GetUserLoginHistory(ctx context.Context, arg GetUserLoginHistoryParams) ([]GetUserLoginHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserLoginHistory, arg.Username, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserLoginHistoryRow
	for rows.Next() {
		var i GetUserLoginHistoryRow
		if err := rows.Scan(
			&i.AttemptTime,
			&i.IpAddress,
			&i.UserAgent,
			&i.Success,
			&i.FailureReason,
			&i.RateLimited,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logLoginAttempt = `-- name: LogLoginAttempt :one

INSERT INTO login_attempts_log (
    username, ip_address, user_agent, success, failure_reason, 
    rate_limited, session_id, device_info
)
VALUES (
    $1, 
    $2, 
    $3, 
    $4, 
    $5,
    $6, 
    $7, 
    $8
)
RETURNING id, username, ip_address, user_agent, attempt_time, success, failure_reason, rate_limited, rate_limit_released_at, released_by, session_id, country, city, device_info, created_at
`

type LogLoginAttemptParams struct {
	Username      string
	IpAddress     string
	UserAgent     sql.NullString
	Success       bool
	FailureReason sql.NullString
	RateLimited   sql.NullBool
	SessionID     sql.NullString
	DeviceInfo    pqtype.NullRawMessage
}

// internal/db/query/login_attempts.sql
func (q *Queries) LogLoginAttempt(ctx context.Context, arg LogLoginAttemptParams) (LoginAttemptsLog, error) {
	row := q.db.QueryRowContext(ctx, logLoginAttempt,
		arg.Username,
		arg.IpAddress,
		arg.UserAgent,
		arg.Success,
		arg.FailureReason,
		arg.RateLimited,
		arg.SessionID,
		arg.DeviceInfo,
	)
	var i LoginAttemptsLog
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.IpAddress,
		&i.UserAgent,
		&i.AttemptTime,
		&i.Success,
		&i.FailureReason,
		&i.RateLimited,
		&i.RateLimitReleasedAt,
		&i.ReleasedBy,
		&i.SessionID,
		&i.Country,
		&i.City,
		&i.DeviceInfo,
		&i.CreatedAt,
	)
	return i, err
}

const logRateLimitRelease = `-- name: LogRateLimitRelease :one
INSERT INTO rate_limit_releases (
    client_id, ip_address, username, blocked_at, released_by, 
    released_by_user_id, block_duration, attempts_count, release_reason
)
VALUES (
    $1, 
    $2, 
    $3, 
    $4,
    $5, 
    $6, 
    $7, 
    $8,
    $9
)
RETURNING id, client_id, ip_address, username, blocked_at, released_at, released_by, released_by_user_id, block_duration, attempts_count, release_reason, created_at
`

type LogRateLimitReleaseParams struct {
	ClientID         string
	IpAddress        string
	Username         sql.NullString
	BlockedAt        time.Time
	ReleasedBy       string
	ReleasedByUserID uuid.NullUUID
	BlockDuration    sql.NullInt64
	AttemptsCount    sql.NullInt32
	ReleaseReason    sql.NullString
}

func (q *Queries) LogRateLimitRelease(ctx context.Context, arg LogRateLimitReleaseParams) (RateLimitRelease, error) {
	row := q.db.QueryRowContext(ctx, logRateLimitRelease,
		arg.ClientID,
		arg.IpAddress,
		arg.Username,
		arg.BlockedAt,
		arg.ReleasedBy,
		arg.ReleasedByUserID,
		arg.BlockDuration,
		arg.AttemptsCount,
		arg.ReleaseReason,
	)
	var i RateLimitRelease
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.IpAddress,
		&i.Username,
		&i.BlockedAt,
		&i.ReleasedAt,
		&i.ReleasedBy,
		&i.ReleasedByUserID,
		&i.BlockDuration,
		&i.AttemptsCount,
		&i.ReleaseReason,
		&i.CreatedAt,
	)
	return i, err
}

const manuallyReleaseRateLimit = `-- name: ManuallyReleaseRateLimit :exec
DELETE FROM api_rate_limits
WHERE client_id = $1
  AND endpoint = '/api/v1/auth/login'
`

func (q *Queries) ManuallyReleaseRateLimit(ctx context.Context, clientID string) error {
	_, err := q.db.ExecContext(ctx, manuallyReleaseRateLimit, clientID)
	return err
}

const updateLoginAttemptRelease = `-- name: UpdateLoginAttemptRelease :exec
UPDATE login_attempts_log
SET 
    rate_limit_released_at = NOW(),
    released_by = $1
WHERE ip_address = $2
  AND rate_limited = true
  AND rate_limit_released_at IS NULL
`

type UpdateLoginAttemptReleaseParams struct {
	ReleasedBy sql.NullString
	IpAddress  string
}

func (q *Queries) UpdateLoginAttemptRelease(ctx context.Context, arg UpdateLoginAttemptReleaseParams) error {
	_, err := q.db.ExecContext(ctx, updateLoginAttemptRelease, arg.ReleasedBy, arg.IpAddress)
	return err
}
